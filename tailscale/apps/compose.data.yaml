name: 'data'
services:

  postgres:
    image: 'tensorchord/vchord-postgres:pg18-v0.5.3'
    restart: 'unless-stopped'
    healthcheck:
      test: [ 'CMD', 'bash', '/usr/local/bin/healthcheck.sh' ]
      interval: '30s'
      timeout: '10s'
      retries: 3
      start_period: '40s'
    shm_size: '256mb'
    deploy:
      resources:
        limits:
          memory: '1G'
    networks:
      - 'database'
    environment:
      POSTGRES_PASSWORD_FILE: '/run/secrets/dbpass'
      POSTGRES_USER: 'main'
      POSTGRES_DB: 'main'
      POSTGRES_INITDB_ARGS: '--data-checksums'
    secrets:
      - 'dbpass'
    configs:
      - source: 'initdb'
        target: '/docker-entrypoint-initdb.d/enable-vectorchord.sql'
      - source: 'dbconfig'
        target: '/etc/postgresql/postgresql.conf'
      - source: 'dbhealth'
        target: '/usr/local/bin/healthcheck.sh'
    # Don't define port mappings as we only want to be available to other services inside Docker.
    ports: []
    volumes:
      - type: 'bind'
        source: '/mnt/fast/apps/postgres'
        # As of Postgres 18+ the recommendation is to mount `/var/lib/postgres`
        # as the data directory will now be named according to the major version
        # to assist in upgrade migrations.
        target: '/var/lib/postgresql'
        read_only: false
    command: [ 'postgres', '-c', 'config_file=/etc/postgresql/postgresql.conf' ]

  valkey:
    image: 'valkey/valkey:9.0-alpine'
    restart: 'unless-stopped'
    deploy:
      resources:
        limits:
          memory: '256M'
    networks:
      - 'cache'
    healthcheck:
      test: [ 'CMD', 'valkey-cli', '--raw', 'ping' ]
      interval: '30s'
      timeout: '10s'
      retries: 3
      start_period: '40s'
    configs:
      - source: 'valkey'
        target: '/etc/valkey/valkey.conf'
    # Don't define port mappings as we only want to be available to other services inside Docker.
    ports: []
    command: [ 'valkey-server', '/etc/valkey/valkey.conf' ]

networks:
  cache:
    name: 'cache'
    driver: 'bridge'
    attachable: true
  database:
    name: 'database'
    driver: 'bridge'
    attachable: true

secrets:
  dbpass:
    file: '/mnt/tank4/class1/secrets/postgres/main'

configs:
  initdb:
    content: |
      CREATE EXTENSION IF NOT EXISTS vchord CASCADE;
  dbconfig:
    content: |
      listen_addresses = '*'
      ## Immich's HDD Postgres Settings
      shared_preload_libraries = 'vchord.so'
      search_path = '"$$user", public'
      wal_compression = on
      autovacuum_vacuum_cost_limit = 1000
      ## Zan's "Not On My Machine" Settings
      max_connections = 35
      shared_buffers = 256MB
      effective_cache_size = 768MB
      work_mem = 2MB
      maintenance_work_mem = 64MB
      temp_buffers = 4MB
      max_worker_processes = 4
      max_parallel_workers = 4
      max_parallel_workers_per_gather = 1
      max_parallel_maintenance_workers = 1
      autovacuum = on
      autovacuum_naptime = 30s
      autovacuum_vacuum_scale_factor = 0.2
      autovacuum_analyze_scale_factor = 0.1
      autovacuum_max_workers = 2
      autovacuum_work_mem = 32MB
      wal_level = replica
      max_wal_size = 512MB
      min_wal_size = 64MB
      checkpoint_timeout = 20min
      checkpoint_completion_target = 0.9
      # "off" should be fine on ZFS (otherwise use "local").
      synchronous_commit = local
      log_min_duration_statement = 250ms
      log_checkpoints = off
      log_autovacuum_min_duration = 1s
      log_statement = 'none'
  dbhealth:
    content: |
      #!/usr/bin/env bash
      read_env_or_file() {
          local VAR_NAME="$$1"
          local FILE_VAR_NAME="$${VAR_NAME}_FILE"
          if [[ -n "$${!FILE_VAR_NAME}" && -f "$${!FILE_VAR_NAME}" && -s "$${!FILE_VAR_NAME}" ]]; then
              cat "$${!FILE_VAR_NAME}"
          else
              echo "$${!VAR_NAME}"
          fi
      }
      POSTGRES_DB=$$(read_env_or_file "POSTGRES_DB")
      POSTGRES_USER=$$(read_env_or_file "POSTGRES_USER")
      POSTGRES_PASSWORD=$$(read_env_or_file "POSTGRES_PASSWORD")
      export POSTGRES_DB POSTGRES_USER POSTGRES_PASSWORD
      pg_isready --dbname="$${POSTGRES_DB}" --username="$${POSTGRES_USER}" || exit $?;
      CHKSUM_ERROR_COUNT="$$(psql --dbname="$${POSTGRES_DB}" --username="$${POSTGRES_USER}" --tuples-only --no-align --command='SELECT COALESCE(SUM(checksum_failures), 0) FROM pg_stat_database')";
      if [ "$${CHKSUM_ERROR_COUNT}" != '0' ]; then
        echo "checksum failure count is $${CHKSUM_ERROR_COUNT}";
        exit 1
      fi
  valkey:
    content: |
      appendonly yes
      appendfsync everysec
      auto-aof-rewrite-percentage 100
      auto-aof-rewrite-min-size 32mb
      save 60 100
      maxmemory 180mb
      maxmemory-policy allkeys-lru
